COMMON WEB SECURITY FLAWS (and how to deal with them)
=====================================================

1. Sessions
-----------

Rails automatically automatically creates a session for each user. It's composed of a hash of values and a session id that identifies that hash. 

There are two ways to store the session hash: either the session id is stored in a cookie and have a server-side session hash, or the entire session hash is stored on the client-side. Both require some kind of session cookie with the session id.

The client will include the session id in every request (this is why it's important to encrypt traffic!)

When a user logs in, their user is stored in the session (either as session[:id] or session[:user_id]).

--SESSION HIJACKING--

By default, sessions are stored in a cookie client-side. Someone could sniff the session id over an insecure network.

COUNTERMEASURES: use SSL encryption.

--REPLAY ATTACKS--

If you store sensitive data in a session (like 'money balance') and use client-side session storage, a client could copy the cookie from a previous step with a larger balance, "reversing" a withdrawal!

COUNTERMEASURES: Don't store sensitive data in sessions, especially if you use client-side session storage! Sensitive data should always be stored server-side, e.g. in a database.


2. Cross-Site Request Forgery (CSRF)
--------------------------------------

This attack method works by including malicious code or a link in a page that accesses a web application that the user is believed to have authenticated.

For example, a hacker might include an image tag in blog post like this:

    <img src="http://www.webapp.com/project/1/destroy">

When an authenticated user views the post, it tries to load the "image", sending the session cookie along with the request. The request is authenticated, and it may succeed.

NOTE that the actual crafted image or link doesn't necessarily have to be located in the web application's domain, it can be anywhere - in a forum, blog post or email.

COUNTERMEASURES:
  – Use RESTful routing conventions, so a 'get' request triggered by an image tag won't perform a CRUD operation on a resource at that endpoint. This will stop a basic CSRF attack, but not all.
  – Use a required security token to authenticate requests. This is done by default in Rails. All forms and AJAX requests generated by Rails include the token, and requests that don't include the token are rejected.
  – Require re-authentication for sensitive requests.


3. Cross-Site Scripting (XSS)
-----------------------------

A widespread attack that injects client-side executable code – whether in a blog post, project title, or anywhere where they can input data – that is later displayed to a victim (known as a 'stored' XSS attack). Alternatively, a script could even be passed as a query parameter in a link provided by an attacker ('reflected' XSS).

Most commonly, an attacker injects HTML and/or Javascript.

COUNTERMEASURES:
  – Filter user input. It is essential that you WHITELIST content rather than blacklist it, as blacklists are never complete.
  – "Escaping" user input and application output for the right context (html, javascript). This alters input or output so it is treated as data, not code.
  – Use the HTTPOnly setting on cookies. This makes cookies accessbile via HTTP only, so they can't be accessed through javascript.


4. SQL Injection
----------------

This is difficult to execute in a normally configured Rails application, but it's important to understand the attack.

A hacker attempts to bypass authorization and access database information by passing input that alters a SQL query. For example, it's a pretty terrible idea to write something like this:

  Project.where("name = '#{params[:name]}'")

That naively passes user input to a SQL query. 

COUNTERMEASURES:

Instead, use this syntax with sanitized user input:

  Project.where("name = ?", entered_name)

This is called using a "bind parameter", which separates user-passed data from the actual SQL query. Even if a hacker attempts to pass a query in `entered_name`, the query will treat everything in `entered_name` as data, not code.

In sum, do not use string-building for SQL, but use queries with bind parameters.


5. INSECURE CRYPTO
------------------

Obviously, you should always salt and hash sensitive data. The trick deciding what data is "sensitive." There is such a thing as OVER-securing data, as this can slow your application down unecessarily.

Use transport layer security (SSL/TLS) when you're transferring sensitive data.


