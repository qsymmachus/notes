REACT
=====

Also see `javascript.txt` for some notes on React.

React is a library for building user interfaces in Javascript. It is _not_ a complete framework
for building web applications, it only handles the UI component. In conjunction with other libraries
like React Router and Redux, you can build complete web applications with React.

JSX
---

Here's some JSX:

```
const h1 = <h1>Hello world</h1>
```

JSX is a "syntax extension" (you can think of it as a DSL) for Javascript. It allows you to write
Javascript that looks nearly identical to HTML. JSX must be compiled into valid Javascript.

JSX is _nearly_ identical to HTML, and can have element attributes:

```
let link = <a hrf="https://olmsted.io>My Site</a>
```

JSX can be nested, and multi-lined. When writing multi-line JSX, it must be inclosed in parens:

```
let myDiv = (
  <div>
    <h1>
      Hello world
    </h1>
  </div>  
)
```

NB: a JSX expression must have only _one_ outer element.

```
let thisIsInvalid = (
  <p>Hi</p>
  <p>Hello</p>
)

let thisIsValid = (
  <div>
    <p>Hi</p>
    <p>Hello</p>
  </div>
)
```

JSX IS REALLY JUST A FUNCTION
-----------------------------

JSX is syntactic sugar for the function `React.createElement`:

```
<p color="blue" shadowSize={2}>
  Click Me
</p>


// compiles into

React.createElement(
  "p",
  {color: 'blue', shadowSize: 2},
  'Click Me'
)
```

JSX GOTCHAS
-----------

JSX is nearly identical to HTML, but with a few important differences. 

1. The `class` attribute can't be used in JSX because it's a reserved word in Javascript.
Instead, JSX uses `className`.

2. Self-closing tags like `<br /> and `<img />` _must_ have a final angle bracket (so no `<img>`).


REACT DOM
---------

ReactDOM allows you to actually render JSX within the DOM:

```
import React from 'react';
import ReactDOM from 'react-dom';

const hello = <h1>Hello world</h1>
const targetElement = document.getElementById('app')

ReactDOM.render(hello, targetElement)
```

One important thing to note is that `ReactDOM.render()` only updates DOM elements that have changed.
If you call it twice with the same JSX element, it does nothing. This provides an obvious performance
benefit and relies on React's use of the  _virtual DOM_.

In React, for every DOM object, there's a corresponding object in the virtual DOM. The virtual DOM is a
lightweight copy of the real DOM. Manipulating the virtual DOM is very cheap, while manipulating the real
DOM is very expensive.

When you render a JSX element, the entire virtual DOM is updated. As we said before, this is a cheap 
operation. The virtual DOM is diff'd wit hthe real DOM, and if there is no difference, the real DOM
is left unchanged.

If there is a difference, the real DOM is updated, _but only the elements that have changed._

JAVASCRIPT IN JSX
-----------------

JSX is just Javascript at the end of the day, so you can interpolate Javascript expressions inside your JSX.
This is what JSX a useful templating language. To interpolate code in your JSX, wrap it in curly braces:

```
let h1 = <h1>{'John' + 'Olmsted'}</h1>

let name = 'John Olmsted'
let p = <p>{name}</p>
```

NB: you cannot inject `if` statements into JSX, because it is not an expression. Alternatively, you can
use a ternary conditional, which is an expression. See "Conditionals in JSX" below.

COLLECTIONS IN JSX
------------------

`map` is a great way to translate collections into JSX:

```
const foods = ['apple', 'orange', 'banana']

const foodList = (
  <ul>
    {foods.map(food => <li>{food}</li>}
  </ul>
)
```

When you make a list in JSX, sometimes you will need to include `key`s. A `key` is a special attribute that
React relies on to enforce ordering in lists. Not all lists need keys. Generally, you need keys when:

  1. The list items have some state that must persist from one render to another, like whether a todo item was "done".
  2. The list's order might be shuffled. For example, a list of search results.

It's easy to add `key`s using `map`:

```
const foodList = foods.map((food, i) => <li key={'food_' + i}>{food}</li>)
```

EVENT LISTENERS IN JSX
----------------------

Like HTML elements, JSX elements can have event listeners, like the `onClick` attribute.

```
let goose = 'https://upload.wikimedia.org/wikipedia/commons/e/e4/Canada_goose_flight_cropped_and_NR.jpg'

function honk(e) {
  e.target.setAttribute('src', 'https://example.com/honking_goose.jpg')
  console.log('HONK!')
}

let gooseImg = (
  <img
    src={gooseImg}
    onClick={honk} />
)
```

CONDITIONALS IN JSX
-------------------

We've noted before that you can't inject conditionals into JSX. There are a few ways to work around this.

1. One way is to place the condional _outside_ the JSX, and choose between two different JSX templates based
on some conditonal.

2. Use the ternary operator instead! The ternary operator is an expression, so it evaluates just fine in JSX.

```
let coin = <img src={coinToss() === 'heads' ? 'heads.jpg' : 'tails.jpg'} />
```

3. Use &&, which is also an expression, to determine whether JSX elements render at all:

```
const food = (
  <ul>
    { !baby && <li>Pizza</li> }
    { age > 15 && <li>Brussels Sprouts</li> }
    { age > 20 && <li>Oysters</li> }
    { age > 25 && <li>Grappa</li> }
  </ul>
)
```

REACT COMPONENTS
----------------

Components are the bread and butter of React applications. Components typically encapsulate:

  1. Some HTML to be rendered (in the form of JSX),
  2. Some behavior tied to that HTML (in the form of Javascript functions).

Here's very simple component:

```
import React from 'react'
import ReactDOM from 'react-dom'

class MyComponent extends React.Component {
  get name() {
    return "John"
  }

  render() {
    return <h1>Hello {this.name}!</h1>
  }
}

```

`render` is the only function that _must_ be declared in a component.

Once a component is defined, you can create a Component instance...in JSX!

```
// <MyComponentClass /> is JSX, but instead of rendering HTML, it renders your
// React Component!

ReactDOM.render(
  <MyComponentClass />,
  document.getElementById('app')
);
```

Components make it easy to combine behaviors, like event listeners, with the HTML elements they're
tied to:

```
import React from 'react'
import ReactDOM from 'react-dom'

class Button extends React.Component {
  scream() {
    alert('AAAAAAAAHHH!!!!!')
  }

  render() {
    return <button onClick={this.scream}>AAAAAH!</button>
  }
}
```

NESTING COMPONENTS
------------------

By itself, a component is not very useful. To build a full-fledged UI, you need to start
nesting components.

Say you have this component in one file:

```
import React from 'react'

export class Title extends React.Component {
  render() {
    return <h1>Welcome!</h1>
  }
}

You can import it and use it in this file:

```
import React from 'react'

import { Title } from `./NavBar.js'

class Homepage extends React.Component {
  render() {
    return (
      <div>
        <Title /> // Check it out, we're nesting a component instance here.
        <p>Hello and welcome to my website.</p>
      </div>
    )
  }
}
```

